import * as crypto from 'crypto';
import Connection from '../Connection';
import Message from '../Message';
import MessageReader from '../MessageReader';
import debug from '../debug';

const SUB_PARSERS: Array<(conn: Connection, reader: MessageReader) => void> = [];

SUB_PARSERS[0] = function Parser$AuthenticationOk(conn: Connection, reader: MessageReader) {
    /*
     * conn._authenticated is being set to true in the ReadyForQuery parser.
     * ReadyForQuery will also resolve the DeferredPacket generated by the StartupMessage Packet
     * and thus fire the connect event - registered in the Connection constructor.
     */
    conn._authenticated = true;
    conn._queueShift().resolve();
}

SUB_PARSERS[2] = function Parser$AuthenticationKerberosV5(conn: Connection, reader: MessageReader) {
    throw new Error('AuthenticationKerberosV5 not yet implemented');
}

SUB_PARSERS[3] = function Parser$AuthenticationCleartextPassword(conn: Connection, reader: MessageReader) {
    if (!conn.options.password) {
        throw new Error('password not provided');
    }

    const msg = new Message();
    msg.addPasswordMessage(conn.options.password);
    conn._writeMessage(msg, true);
}

SUB_PARSERS[5] = function Parser$AuthenticationMD5Password(conn: Connection, reader: MessageReader) {
    if (!conn.options.password) {
        throw new Error('password not provided');
    }

    // NOTE: The password hashing algorithm as written in SQL:
    //   SELECT 'md5' || MD5(MD5('password' || 'user') || 'salt')
    const salt = reader.getBytes(4);

    const innerHash = crypto.createHash('md5');
    innerHash.update(conn.options.password + conn.options.user);

    const outerHash = crypto.createHash('md5');
    outerHash.update(innerHash.digest('hex'))
    outerHash.update(salt);

    const result = 'md5' + outerHash.digest('hex');

    const msg = new Message();
    msg.addPasswordMessage(result);
    conn._writeMessage(msg, true);
}

SUB_PARSERS[6] = function Parser$AuthenticationSCMCredential(conn: Connection, reader: MessageReader) {
    throw new Error('AuthenticationSCMCredential not yet implemented');
}

SUB_PARSERS[7] = function Parser$AuthenticationGSS(conn: Connection, reader: MessageReader) {
    throw new Error('AuthenticationGSS not yet implemented');
}

SUB_PARSERS[8] = function Parser$AuthenticationGSSContinue(conn: Connection, reader: MessageReader) {
    throw new Error('AuthenticationGSSContinue not yet implemented');
}

SUB_PARSERS[9] = function Parser$AuthenticationSSPI(conn: Connection, reader: MessageReader) {
    throw new Error('AuthenticationSSPI not yet implemented');
}


export const type = 'R';
export default function Parser$Authentication(conn: Connection, reader: MessageReader) {
    if (conn._authenticated) {
        throw new Error('already authenticated');
    }

    const type = reader.getInt32();
    const subParser = SUB_PARSERS[type];

    if (!subParser) {
        throw new Error('authentication method not implemented');
    }

    debug.enabled && debug('>>>', `Parser$Authentication => ${subParser.name}`);

    subParser(conn, reader);
}
