'use strict';

const crypto  = require('crypto');
const debug   = require('../debug');
const packets = require('../packets');


Parser$AuthenticationOk.type = 0;
function Parser$AuthenticationOk(conn, reader) {
	/*
	 * conn._authenticated is being set to true in the ReadyForQuery parser.
	 * ReadyForQuery will also resolve the DeferredPacket generated by the StartupMessage Packet
	 * and thus fire the connect event - registered in the Connection constructor.
	 */
}

Parser$AuthenticationKerberosV5.type = 2;
function Parser$AuthenticationKerberosV5(conn, reader) {
	reader.ensureExactLength(9);
	throw new Error('AuthenticationKerberosV5 not yet implemented');
}

Parser$AuthenticationCleartextPassword.type = 3;
function Parser$AuthenticationCleartextPassword(conn, reader) {
	if (!conn.options.password) {
		throw new Error('password not provided');
	}

	// do not use _pushPacket() since _authenticated is still false
	conn._writePacket(packets.PasswordMessage(conn.options.password));
}

Parser$AuthenticationMD5Password.type = 5;
function Parser$AuthenticationMD5Password(conn, reader) {
	if (!conn.options.password) {
		throw new Error('password not provided');
	}

	/*
	 * The password hashing algorithm:
	 * SELECT 'md5' || MD5(MD5('password' || 'user') || 'salt')
	 */
	const salt = reader.getBytes(4);

	const innerHash = crypto.createHash('md5');
	innerHash.update(conn.options.password + conn.options.user);

	const outerHash = crypto.createHash('md5');
	outerHash.update(innerHash.digest('hex'))
	outerHash.update(salt);

	const result = 'md5' + outerHash.digest('hex');

	// do not use _pushPacket() since _authenticated is still false
	conn._writePacket(packets.PasswordMessage(result));
}

Parser$AuthenticationSCMCredential.type = 6;
function Parser$AuthenticationSCMCredential(conn, reader) {
	throw new Error('AuthenticationSCMCredential not yet implemented');
}

Parser$AuthenticationGSS.type = 7;
function Parser$AuthenticationGSS(conn, reader) {
	throw new Error('AuthenticationGSS not yet implemented');
}

Parser$AuthenticationGSSContinue.type = 8;
function Parser$AuthenticationGSSContinue(conn, reader) {
	throw new Error('AuthenticationGSSContinue not yet implemented');
}

Parser$AuthenticationSSPI.type = 9;
function Parser$AuthenticationSSPI(conn, reader) {
	throw new Error('AuthenticationSSPI not yet implemented');
}


const SUB_PARSERS = (() => {
	const subParsers = [];

	[
		Parser$AuthenticationOk,
		Parser$AuthenticationKerberosV5,
		Parser$AuthenticationCleartextPassword,
		Parser$AuthenticationMD5Password,
		Parser$AuthenticationSCMCredential,
		Parser$AuthenticationGSS,
		Parser$AuthenticationGSSContinue,
		Parser$AuthenticationSSPI,
	].forEach((subParser) => {
		subParsers[subParser.type] = subParser;
	});

	return subParsers;
})();


Parser$Authentication.type = 'R';
function Parser$Authentication(conn, reader) {
	if (conn._authenticated) {
		throw new Error('already authenticated');
	}

	const type = reader.getInt32();
	const subParser = SUB_PARSERS[type];

	if (!subParser) {
		throw new Error('authentication method not implemented');
	}

	debug.enabled && debug('>>>', `Parser$Authentication => ${subParser.name}`);

	subParser(conn, reader);
}


module.exports = Parser$Authentication;
